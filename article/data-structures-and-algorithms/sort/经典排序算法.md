# 经典排序算法

> 说实话直接叫我手撕所有经典的排序算法（插入、选择、冒泡、快排、归并、桶、计数、基数），并分析所有排序算法的最好、最坏、平均时间复杂度，空间复杂度，是否稳定，各排序算法适用的场景... 说实话我不行，水平太菜了...

## 0. 序言

我将从三个方面来记录学习排序算法：

1. 衡量排序算法的指标是啥 ？
2. 目前经典排序的算法
3. 各排序算法适用场景

## 1. 衡量排序算法的指标

### 1.1 复杂度

**复杂度**分为时间复杂度和空间复杂度。时间复杂度和空间复杂度来是判断算法效率的重要指标。一般我们使用大O复杂度表示法。

时间复杂度又分为最好时间复杂度、最坏时间复杂度、平均时间复杂度、均摊时间复杂度等。空间复杂度也可以分为最好、最坏、平均空间复杂度。一般我们说的**时间复杂度**都是指**最坏情况**下的时间复杂度。

**最好**：最好情况下的复杂度。举个”栗子“：现在你需要给一组数据（整数）按从小到大排序，数据有序情况不可知。那么最好的情况则是给定的数据已经按从小到大的顺序排好了。

**最坏**：最坏情况下的复杂度。还是引用从小到大排序的栗子，最坏情况则是给定的数据是从大到小排序的，如5、4、3、2、1。

**平均**：平均情况下的复杂度。举个栗子：在一组数据（无序）中查找某个值。最好情况则是数据中的第一个值就是我需要找到即需查找一次，最坏情况则是这个元素在数据的最后一位或数据中没有改元素，那么平均的来算就是：（1+2+3+...+N+N)/(N+1)。为什么有2个N，其中最后一个N是没有找到。使用大O复杂度表示法则是：O（N）。

**均摊**：均摊是平均的一种特殊情况。举个栗子：现在需要不断地往容器中添加数据，当容器满了的时候，创建一个新容器其容量是目前容器的2倍。则需要把旧容器中的数据移动到新容器中。假设最初容器容量为k，现在开始插入数据，操作的次数为：1,1,1...,1,k+1,1,1,1...,1,2k+1,1,1,1...,1,4k+1,1,1,1....

那时间复杂度怎么算呢？

![](./images/均摊时间复杂度.png)

将扩容移动的次数均摊到每次插入上，所以均摊时间复杂度为：O（1）。

### 1.2 稳定性

什么叫**稳定性**？

举个栗子：比如数列 5、4、2、3、6、1、3，如果进行排序后这两个3的相对位置没有改变，则排序算法是稳定的，如果两个3的相对位置发生改变，则排序算法是不稳定的。相对位置可以这样理解：将第一个3记为3(a)，第二个3记为3(b)，如果排序后3(a)在3(b)前面则说明是稳定的，相反则说明不稳定。

## 2. 经典排序算法

> 使用go语言实现，相关排序算法。

### 2.1 冒泡排序

通过比较相邻元素的大小进行交换，一轮比较后可以确定一个元素的位置（此轮最大或最小元素）。

```go
/**
冒泡排序：升序
*/
func bubbleSort(data []int) {
	// 作为临时变量来交换
	var tmp int
	for i := 0; i < len(data); i++ {
		for j := 1; j < len(data)-i; j++ {
			if data[j-1] > data[j] {
				tmp = data[j-1]
				data[j-1] = data[j]
				data[j] = tmp
			}
		}
	}
}

/**
冒泡排序升级版：添加一个判断符，若一轮相邻元素之间没有交换，则数据已经有序
*/
func bubbleSortUpgrade(data []int) {
	// 作为临时变量来交换
	var tmp int
	// 用来标记一轮中相邻元素有没有交换
	var flag bool
	for i := 0; i < len(data); i++ {
		flag = true
		for j := 1; j < len(data)-i; j++ {
			if data[j-1] > data[j] {
				// 标记有交换
				flag = false
				tmp = data[j-1]
				data[j-1] = data[j]
				data[j] = tmp
			}
		}
		if flag {
			break
		}
	}
}
```

**冒泡算法的复杂度分析**：

最好时间复杂度：O（N），已经有序只需要查询一轮。

最坏时间复杂度：O（N^2）,假设每次都交换，n-1,n-2,n-3...,1

平均时间复杂度：O（N^2）。这边可以通过有序度来计算。

什么叫**有序度**？有序度是数组中具有有序关系的元素对的个数。有序元素对：a[i] <= a[j]，如果 i < j。

如数组4、3、2、1,则有序度为0。数组1、2、3、4，则有序度为n * (n-1) / 2，也就是6。完全有序的数组的有序度叫作满有序度。**逆有序度**=**满有序度** - **有序度** 。排序的过程就是增加有序度，减少逆有序度，达到满有序度。

冒泡排序是相邻元素的比较和交换，每次交换有序度+1，逆有序度-1，所以**交换的次数即逆有序度**。**最多**交换次数即有序度为0，那么逆有序度为n * (n-1) / 2。**最少**交换次数即满有序度，那么逆有序度为0。所以平均交换次数为  n * (n-1) / 4 。

空间复杂度：O（1），属于原地置换算法

稳定：相邻元素大小值相等不做交换。

### 2.2 选择排序

选择排序每次一轮查询时选出最小（或最大值）与改轮最左边（或最右边）元素交换。

```golang
/**
	选择排序：升序
 */
func selectSort(data []int) {
	// select sort
	var minIndex, tmp int
	for i := 0; i < len(data); i++ {
		minIndex = i
		for j := i + 1; j < len(data); j++ {
			if data[minIndex] > data[j] {
				minIndex=j
			}
		}
		if minIndex!=i{
			tmp=data[i]
			data[i]=data[minIndex]
			data[minIndex]=tmp
		}
	}
}
```

最好、最坏、平均时间复杂度：O（N^2）

空间复杂度：O（1），属于原地排序算法。

不稳定：如5,8,5,2,9 第一次找到最小元素 2 与第一个 5 进行交换。

### 2.3 插入排序

插入排序即对一个一个元素进行插入，插入前元素都是有序的，对即将插入的元素，通过对比元素的值，移动有序元素位置，为即将插入的元素找到合适的位置。

```golang
/**
插入排序：升序
*/
func insertionSort(data []int) {
	// 长度小于 2
	if len(data) < 2 {
		return
	}
	var value, j int
	for i := 1; i < len(data); i++ {
		value = data[i]
		j = i - 1
		for ; j >= 0; j-- {
			if value < data[j] {
				data[j+1] = data[j]
			} else {
				break
			}
		}
		data[j+1] = value
	}
}
```

最好时间复杂度：O(N)，数组原来就有序，会每步插入会执行break。

最坏时间复杂度：O(N^2)，数组原来是倒序。

平均时间复杂度：O(N^2)，在一个数组中插入一个元素的时间复杂度是O(N)，循环n次，则时间复杂度为O(N^2)。

空间复杂度：O（1），属于原地置换算法。

稳定性：由于相同大小元素不移动，稳定。

**插入排序和冒泡排序比较**

可以比较10000个随机数，两个算法的时间比较。

```go
func main() {
	dataBubble := make([]int, 10000)
	dataInsert := make([]int, 10000)
	var temp int
	for i := 0; i < 10000; i++ {
		temp = rand.Intn(1000)
		dataBubble[i] = temp
		dataInsert[i] = temp
	}
	starTime := time.Now()
	bubbleSortUpgrade(dataBubble)
	fmt.Println("bubble sort used time: ", time.Now().Sub(starTime))
	starTime = time.Now()
	insertionSort(dataInsert)
	fmt.Println("insert sort used time: ", time.Now().Sub(starTime))
}
```

随机生成10000个数，然后分别使用冒泡和插入排序对10000个数进行排序（也可以讲10000个数设置为有序），会发现插入排序所消耗的时间会比冒泡排序消耗的时间少。why ？

看代码：

**冒泡**：

![](./images/冒泡交换.png)

**插入**：

![](./images/插入交换.png)

冒泡主要时间的消耗是：一次交换需要3个赋值语句。

### 2.4 快速排序

快速排序其实是冒泡排序的改进。在数据中选择一个分界值，通过一趟排序后会将要排序的数据分割成独立的两部分，其中一部分数据大于等于分界值，另一部分小于等于分界值。按照此方法将分界值的左边和右边再次进行排序，重复执行直到整个数据变成有序序列。这是一个递归的过程。

```go
/**
快速排序：升序
*/
func quickSort(data []int, start, end int) {
	if start >= end {
		return
	}
	pivot := partition(data, start, end)
	quickSort(data, start, pivot-1)
	quickSort(data, pivot+1, end)
}

func partition(data []int, p, r int) int {
	var tmp int
	pivotValue := data[r]
	i := p
	for j := p; j <= r-1; j++ {
		if data[j] < pivotValue {
			// 交换
			tmp = data[i]
			data[i] = data[j]
			data[j] = tmp
			i++
		}
	}
	tmp = data[i]
	data[i] = pivotValue
	data[r] = tmp
	return i
}
```

最好时间复杂度：O（NlogN），每次的pivot的值选取的很好，partition将左右均分。

最坏时间复杂度：O（N^2），每次的pivot的值选的很差，partition只能分出一个。

平均时间复杂度：O(NlogN)，证明见知乎：https://www.zhihu.com/question/22393997

空间复杂度：O（1）

稳定性：不稳定，如：3、1、2、3、1、4、5、6，将第一个3作为pivot的，

### 2.5 归并排序

归并排序采用分治法，**分**：其实就是把未排序数列不断细分，**治**：不断将两个有序数列合并成一个大的有序序列。

```go
/**
归并排序：升序
*/
func mergeSort(data []int, start, end int) {
	if start >= end {
		return
	}
	middle := start + (end-start)/2
	mergeSort(data, start, middle)
	mergeSort(data, middle+1, end)
	merge(data, start, middle, end)
}

func merge(data []int, start, middle, end int) {
	tempData := make([]int, end-start+1)
	for i := 0; i < end-start+1; i++ {
		tempData[i] = data[start+i]
	}
	currentIndex := start
	var i, j int
	for i, j = 0, middle-start+1; i <= middle-start && j < end-start+1; {
		if tempData[i] <= tempData[j] {
			data[currentIndex] = tempData[i]
			i++
		} else {
			data[currentIndex] = tempData[j]
			j++
		}
		currentIndex++
	}
	for ; i <= middle-start; i++ {
		data[currentIndex] = tempData[i]
		currentIndex++
	}
	for ; j < end-start+1; j++ {
		data[currentIndex] = tempData[j]
		currentIndex++
	}
}
```

最好时间复杂度：O（NlogN）

最坏时间复杂度：O（NlogN）

平均时间复杂度：O（NlogN）

> 归并排序的时间复杂度是O（NlogN）
>
> 证明：T（N）=2 * T (N/2)+N=4 * T (N/4) + 2 * N = 8 * T (N/8) + 3 * N = ... = 2^k * T (N/2^k) + k * N  
>
> T（1）= C ；当 n 为 1 时只需要常量级的执行时间
>
> 当 k 很大时，N/2^k =1 时，k=log2 N，所以 T（N）= C * N+NlogN，使用大O时间复杂度表示为：O（N）= NlogN

空间复杂度：O（N），合并时使用的空间

稳定性：稳定，合并前后顺序不变。

**归并排序的优化点**：merge的时候判断下左边有序序列的最大值是否小于右边有序序列的最小值，如果是其实就不需要进行merge操作即**治（并）**。

```go
/**
归并排序：升序
*/
func mergeSortImprove(data []int, start, end int) {
	if start >= end {
		return
	}
	middle := start + (end-start)/2
	mergeSort(data, start, middle)
	mergeSort(data, middle+1, end)
	// 当左边最大元素大于右边最小元素时，进行合并
	if data[middle] > data[middle+1] {
		merge(data, start, middle, end)
	}
}
```

### 2.6 桶排序

什么叫桶排序？桶排序使用了分治思想，将数据分到几个有序的桶，将桶里的数据进行排序，待桶内的数据排序完后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。

![](./images/桶排序.png)

举个例子如上图所示，需要对一组数据进行排序，数据范围是 0 ～199 ，按照数据值的大小分配到 5 个桶中，然后对每个桶中的数据进行排序。

### 2.7 计数排序



### 2.8 基数排序




## 3. 各排序算法适用场景



## 4. 总结